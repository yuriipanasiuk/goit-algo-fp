### Завдання 1. Структури даних. Сортування. Робота з однозв'язним списком

Для реалізації однозв'язного списку (приклад реалізації можна взяти з конспекту) необхідно:

- Написати функцію, яка реалізує реверсування однозв'язного списку, змінюючи посилання між вузлами.
- Розробити алгоритм сортування для однозв'язного списку (наприклад, сортування вставками або злиттям).
- Написати функцію, що об'єднує два відсортовані однозв'язні списки в один відсортований список.

### Завдання 2. Рекурсія. Створення фрактала “дерево Піфагора” за допомогою рекурсії

Необхідно написати програму на Python, яка використовує рекурсію для створення фрактала **“дерево Піфагора”**.  
Програма має візуалізувати фрактал, а користувач повинен мати можливість вказати рівень рекурсії.

### Завдання 3. Дерева, алгоритм Дейкстри

Розробіть алгоритм Дейкстри для знаходження найкоротших шляхів у зваженому графі, використовуючи бінарну купу.  
Завдання включає:

- Створення графа.
- Використання бінарної купи для оптимізації вибору вершин.
- Обчислення найкоротших шляхів від початкової вершини до всіх інших.

### Завдання 4. Візуалізація бінарної купи

Використовуючи наданий базовий код, побудуйте функцію, що візуалізує бінарну купу.

### Завдання 5. Візуалізація обходу бінарного дерева

Використовуючи код із завдання 4 для побудови бінарного дерева, створіть програму на Python, яка візуалізує обходи дерева:

- У глибину (DFS).
- У ширину (BFS).

Програма повинна відображати кожен крок: вузли мають змінювати колір залежно від послідовності обходу.  
Кольори вузлів — у 16-системі RGB (наприклад, `#1296F0`). Відтінки мають поступово переходити від темних до світлих, відображаючи порядок відвідування. Кожен відвідуваний вузол отримує унікальний колір.

### Завдання 6. Жадібні алгоритми та динамічне програмування

Необхідно написати програму на Python, яка розв’язує задачу вибору їжі з максимальною сумарною калорійністю в межах обмеженого бюджету, використовуючи два підходи:

- Жадібний алгоритм.
- Алгоритм динамічного програмування.

Дані про їжу представлені у вигляді словника, де ключ — назва страви, а значення — словник із вартістю та калорійністю.

### Завдання 7. Використання методу Монте-Карло

Необхідно написати програму на Python, яка:

- Імітує велику кількість кидків двох шестигранних кубиків.
- Обчислює суму чисел, що випали на кубиках за кожен кидок.
- Підраховує, скільки разів з’явилася кожна можлива сума (від 2 до 12).
- Обчислює емпіричну ймовірність кожної суми на основі симуляції.

На основі результатів створіть таблицю або графік, що відображає ймовірності кожної суми, отримані за допомогою методу Монте-Карло.

## Висновки

У рамках виконання завдання було реалізовано програмне моделювання кидання двох стандартних шестигранних ігрових кубиків із використанням методу Монте-Карло. Симуляція проводилася для різної кількості кидків (100, 1000, 10 000 та 100 000), що дозволило оцінити емпіричні ймовірності появи кожної можливої суми від 2 до 12.

Результати демонструють чітку залежність точності оцінки від обсягу вибірки. При малій кількості кидків (100–1000) емпіричні ймовірності мають помітні відхилення від теоретичних значень через випадкову природу симуляції. Зі збільшенням кількості ітерацій відхилення суттєво зменшуються: при 100 000 кидків отримані ймовірності практично збігаються з аналітичними значеннями (максимальна різниця становить менше 0.002).

Це підтверджує фундаментальний принцип методу Монте-Карло та закону великих чисел: при достатньо великій кількості незалежних випробувань емпірична частота події наближається до її теоретичної ймовірності.

Отримані результати повністю відповідають відомим аналітичним розрахункам для даної задачі (максимальна ймовірність — 6/36 ≈ 16.67% для суми 7, мінімальна — 1/36 ≈ 2.78% для сум 2 та 12), що свідчить про коректність реалізації алгоритму.

Таким чином, виконаний програмний експеримент наочно ілюструє ефективність методу Монте-Карло для оцінки ймовірностей у дискретних ймовірнісних задачах і демонструє важливість вибору достатньо великої кількості симуляцій для досягнення високої точності.
